The New York Times strives to deliver our users the best possible experience. On Android, this means creating an offline-first, reactive architecture that minimizes how much data our app uses. The Android team used open source libraries including Dagger, RxJava, OkHttp, and Okio. We then tie these technologies together with a simple, open-source library we have developed called Store.A Store (instance) is that magical middle piece that aims to simplify fetching, parsing, storage, and retrieval of data in your application. A Store follows the Repository pattern while exposing a Reactive (RxJava) API that adheres to a unidirectional data flow.Store provides a level of abstraction between UI elements and data operations. We tried to simplify the logic around data fetching for offline and online users, helping us be an offline-first application. Stores also help boost app performance by preventing unnecessary network calls or disk reads. The architecture of our flagship news app is made up of immutable data (M)odels, Custom (V)iews, (P)resenters and (S)tores — which we like to call MVPS.The Problem:

Modern Android apps need their data representations to be fluid and always available.
Users expect their UI experience to never be degraded (blocked) by new data loads. Whether an application is a social, news, or business-to-business app, users expect a seamless experience both online and offline.
International users expect minimal data downloads, as megabytes of download can quickly turn into astronomical phone bills.

Our Solution
Within our app we create lightweight, single responsibility Stores.  A Store is responsible for managing a particular data request.
Background:
A couple of years ago we rewrote our flagship news reader app to leverage new patterns in Android such as reactive architectures and dependency injection. During the rewrite we created something called a ContentManager which ended up being a middle tier god class that all data operations passed through. After our rewrite we started thinking of ways to break up this class into single responsibility fetchers/savers/parsers. The idea for Stores was born. 
Fast forward 6 months and we now had a few base classes to extend from that would enforce a Repository pattern. From a technical standpoint we were able to solve our specific issue: each store would now be responsible for abstracting a single fetcher/parser/persister.
A few months later, a new app (Crosswords) was getting spiraled up. Unlike our main app which uses a custom network client and parser implementation, Crosswords was built using Retrofit/SQLite. We took steps to make the Store library more configurable, moving a few specific implementation into the Middleware package and keeping Stores as generic and pluggable as possible.
While creating the Middleware module, we also created a new module for our specific persistence implementation called FileSystem.  We found that streaming json from network to disk to be the fastest type of persistence. Subclassing stores did not seem to be optimal when using Retrofit so we created builders for store instantiation. As the store module grew into four distinct packages, we separated it into its own project and git repo. 
Fast forward to now: we are using Stores in two apps as well as any Maker Day project we start on. The core team wanted to push out our first open source library and Store seemed like it would be a great contribution to the community. Now came the hard part: how to go from internal code to open source.
What to open source?
Like most internal code, we had a few blockers prior to going open source. One of our issues was that we rely heavily on Guava and did not want to release a library that depends on 10k methods. After a bit of trial and error we were able to separate/shade a jar containing only a subset of Guava, the cache implementation.
Next, we had a few helper methods from Guava that we ended up rewriting. One of our devs did a fine job with writing a breadth-first file traversal somewhere besides a whiteboard. Some other tasks included removing anything specific to our internal systems, creating proper build scripts, creating README and diagrams, registering with Maven Central, and dropping dependencies to internal build tools with a switch to Travis for CI.
When it was all said and done we had four modules which could be turned into libraries (all with minimal method counts):
Store – Store artifact which contains base classes for constructing a new Store Implementation
com.nytimes.android:store:1.0.1
Middleware – Sample gson parsers to use when building a store.
com.nytimes.android:middleware:1.0.1
FileSystem – A disk persistence implementation that can stream to disk from network (contains a bit of middleware we will go into below)
com.nytimes.android:filesystem:1.0.1
Cache – Extracted from Guava
com.nytimes.android:cache:1.0.1
How does it work?
When you create an implementation of a Store, you provide it with a Fetcher. Additionally, you can define how your Store will cache data, both in-memory and on-disk, as well as how to parse it. Since you’ll be getting back an Observable of your data, threading is a breeze! Once a Store is built, it will handle the logic around data flow, allowing your views to use the best data source and ensuring that the newest data is always available for later offline use. Stores can be customized to work with your own implementations or use our included middleware.
Store leverages RxJava and multiple request throttling to prevent excessive calls to the network and disk cache. By utilizing our library, you eliminate the possibility of flooding your network with the same request while adding two layers of caching (memory + disk).
Fully Configured Store
Let’s start by looking at what a fully configured store looks like, we will then walk through a few simpler examples. See the README for a more detailed rundown of functionality.

The above builder is how we work with data at The New York Times, no loaders, content providers,  sync adapters, or database required.
With the above setup you have:

In-Memory Caching
Disk caching
Parsing through streaming API
Ability to get cached data or bust through your caches

And now for the details:
Creating a Store

Barcodes
Stores use Barcodes as identifiers for data. A Barcode is a class that holds two strings: type and key. The two values act as unique identifiers for your data. When .fetcher() is called, it will be passed to the Barcode. Similarly, the Barcode will be used as a identifier in your cache(s).
Barcode barcode = new Barcode("Article", "42");
Public Interfaces for Accessing Data — Get, Fetch, Stream
The first time you subscribe to store.get(barcode), the response will be stored in an in-memory cache using the Barcode as a key. All subsequent calls to store.get(barcode) will retrieve the cached version of the data, minimizing unnecessary data calls. This prevents your app from fetching fresh data over the network (or from another external data source) in situations when doing so would unnecessarily waste bandwidth and battery. A great use case: any time your views get recreated after a rotation, they will be able to request the cached data from your store. Having your data available has helped us retain less within our view layer.
So far our Store’s data flow looks like this:

By default 100 items will be cached in memory for 24 hours. You may pass in your own instance of a Cache to override the default policy.
Busting Through the Cache
Alternatively you can call store.fetch(barcode) to get an Observable that skips the memory (and optional disk cache).
A fresh data call will look like:

Overnight background updates within our app use .fetch() to make sure that calls to store.get() will not have to hit the network during normal usage. Another good use case for .fetch() is pull to refresh.
Calls to both .fetch() and get() emit one value and then call onCompleted() or throw an error.
Adding a Parser
Since it is rare that data comes from the network in the format that your views need, Stores can delegate to a parser by using a ParsingStoreBuilder rather than a StoreBuilder.

Our updated data flow now looks like this:
store.get() ->

Middleware — GsonSourceParser
As mentioned in the intro, we are also releasing a separate middleware library with parsers to help in cases where your Fetcher is a Reader, BufferedSource or String and your parser is Gson: GsonReaderParser, GsonSourceParser, GsonStringParser.
Our example can now be rewritten as:

Disk Caching
Stores can enable disk caching by passing in a Persister to the builder. Whenever a new network request is made, it will first write to the disk cache and then read from the disk cache. (See the README for example code.)
Now our data flow looks like:

Ideally, data will be streamed from network to disk using either a BufferedSource or Reader as your network raw type (rather than String).
Stores don’t care how you’re storing or retrieving your data from disk. As a result, you can use stores with object storage or any database (Realm, SQLite, CouchDB, Firebase, etc.). The only requirement is that you can store and retrieve the data using the same type as your Fetcher. Technically there is nothing stopping you from implementing an in-memory cache for the Persister implementation and having two levels of in memory caching (one with inflated and one with deflated models, allowing for sharing of the Persister cache data between stores.
Note: When using a parser and a disk cache, the parser will be called after fetching from disk and not between the fetcher and persister which will allow your persister to work on the network stream directly.
Bonus: FileSystem & SourcePersister
You may have noticed in the first example that we were using something called a SourcePersister. We’ve found the fastest form of persistence is streaming network responses directly to disk. As a result, we have included a separate artifact with a reactive FileSystem which depends on Okio BufferedSources. We have also included a SourcePersister which will give you disk caching that works beautifully with the middleware: GsonSourceParser. Let’s revisit an example that is structured like our first one, this time looking at a real Store we built for our New York Times Best Sellers screen:

We recommend using the above builder to build most Stores. The SourcePersister implementation has a tiny memory footprint as it will stream bytes from network to disk and then from disk to parser. The streaming nature of our stores allows us to download dozens of 1MB+ JSON responses without worrying about OOM on low-memory devices. As mentioned above, Stores allow us to do things like calling bookStore.get() a dozen times asynchronously before our Main Activity finishes loading without blocking the main thread or flooding our network.
Conclusion
We thought about what is truly necessary for data retrieval and concluded we only really need files, Guava caches, and a Reactive API — no loaders, content providers, sync adapters, or databases required. We enjoy our lightweight setup and hope you will too. We’d love to hear about what you build. And your contributions are welcome as well.
Our Solution
Within our app we create lightweight, single responsibility Stores.  A Store is responsible for managing a particular data request.Background:
A couple of years ago we rewrote our flagship news reader app to leverage new patterns in Android such as reactive architectures and dependency injection. During the rewrite we created something called a ContentManager which ended up being a middle tier god class that all data operations passed through. After our rewrite we started thinking of ways to break up this class into single responsibility fetchers/savers/parsers. The idea for Stores was born. Fast forward 6 months and we now had a few base classes to extend from that would enforce a Repository pattern. From a technical standpoint we were able to solve our specific issue: each store would now be responsible for abstracting a single fetcher/parser/persister.A few months later, a new app (Crosswords) was getting spiraled up. Unlike our main app which uses a custom network client and parser implementation, Crosswords was built using Retrofit/SQLite. We took steps to make the Store library more configurable, moving a few specific implementation into the Middleware package and keeping Stores as generic and pluggable as possible.While creating the Middleware module, we also created a new module for our specific persistence implementation called FileSystem.  We found that streaming json from network to disk to be the fastest type of persistence. Subclassing stores did not seem to be optimal when using Retrofit so we created builders for store instantiation. As the store module grew into four distinct packages, we separated it into its own project and git repo. Fast forward to now: we are using Stores in two apps as well as any Maker Day project we start on. The core team wanted to push out our first open source library and Store seemed like it would be a great contribution to the community. Now came the hard part: how to go from internal code to open source.What to open source?
Like most internal code, we had a few blockers prior to going open source. One of our issues was that we rely heavily on Guava and did not want to release a library that depends on 10k methods. After a bit of trial and error we were able to separate/shade a jar containing only a subset of Guava, the cache implementation.Next, we had a few helper methods from Guava that we ended up rewriting. One of our devs did a fine job with writing a breadth-first file traversal somewhere besides a whiteboard. Some other tasks included removing anything specific to our internal systems, creating proper build scripts, creating README and diagrams, registering with Maven Central, and dropping dependencies to internal build tools with a switch to Travis for CI.When it was all said and done we had four modules which could be turned into libraries (all with minimal method counts):Store – Store artifact which contains base classes for constructing a new Store Implementation
com.nytimes.android:store:1.0.1Middleware – Sample gson parsers to use when building a store.
com.nytimes.android:middleware:1.0.1FileSystem – A disk persistence implementation that can stream to disk from network (contains a bit of middleware we will go into below)
com.nytimes.android:filesystem:1.0.1Cache – Extracted from Guava
com.nytimes.android:cache:1.0.1How does it work?
When you create an implementation of a Store, you provide it with a Fetcher. Additionally, you can define how your Store will cache data, both in-memory and on-disk, as well as how to parse it. Since you’ll be getting back an Observable of your data, threading is a breeze! Once a Store is built, it will handle the logic around data flow, allowing your views to use the best data source and ensuring that the newest data is always available for later offline use. Stores can be customized to work with your own implementations or use our included middleware.Store leverages RxJava and multiple request throttling to prevent excessive calls to the network and disk cache. By utilizing our library, you eliminate the possibility of flooding your network with the same request while adding two layers of caching (memory + disk).Fully Configured Store
Let’s start by looking at what a fully configured store looks like, we will then walk through a few simpler examples. See the README for a more detailed rundown of functionality.The above builder is how we work with data at The New York Times, no loaders, content providers,  sync adapters, or database required.With the above setup you have:And now for the details:Creating a StoreBarcodes
Stores use Barcodes as identifiers for data. A Barcode is a class that holds two strings: type and key. The two values act as unique identifiers for your data. When .fetcher() is called, it will be passed to the Barcode. Similarly, the Barcode will be used as a identifier in your cache(s).Public Interfaces for Accessing Data — Get, Fetch, Stream
The first time you subscribe to store.get(barcode), the response will be stored in an in-memory cache using the Barcode as a key. All subsequent calls to store.get(barcode) will retrieve the cached version of the data, minimizing unnecessary data calls. This prevents your app from fetching fresh data over the network (or from another external data source) in situations when doing so would unnecessarily waste bandwidth and battery. A great use case: any time your views get recreated after a rotation, they will be able to request the cached data from your store. Having your data available has helped us retain less within our view layer.So far our Store’s data flow looks like this:By default 100 items will be cached in memory for 24 hours. You may pass in your own instance of a Cache to override the default policy.Busting Through the Cache
Alternatively you can call store.fetch(barcode) to get an Observable that skips the memory (and optional disk cache).A fresh data call will look like:
Overnight background updates within our app use .fetch() to make sure that calls to store.get() will not have to hit the network during normal usage. Another good use case for .fetch() is pull to refresh.Calls to both .fetch() and get() emit one value and then call onCompleted() or throw an error.Adding a Parser
Since it is rare that data comes from the network in the format that your views need, Stores can delegate to a parser by using a ParsingStoreBuilder rather than a StoreBuilder.Our updated data flow now looks like this:
store.get() ->Middleware — GsonSourceParser
As mentioned in the intro, we are also releasing a separate middleware library with parsers to help in cases where your Fetcher is a Reader, BufferedSource or String and your parser is Gson: GsonReaderParser, GsonSourceParser, GsonStringParser.Our example can now be rewritten as:
Disk Caching
Stores can enable disk caching by passing in a Persister to the builder. Whenever a new network request is made, it will first write to the disk cache and then read from the disk cache. (See the README for example code.)Now our data flow looks like:Ideally, data will be streamed from network to disk using either a BufferedSource or Reader as your network raw type (rather than String).Stores don’t care how you’re storing or retrieving your data from disk. As a result, you can use stores with object storage or any database (Realm, SQLite, CouchDB, Firebase, etc.). The only requirement is that you can store and retrieve the data using the same type as your Fetcher. Technically there is nothing stopping you from implementing an in-memory cache for the Persister implementation and having two levels of in memory caching (one with inflated and one with deflated models, allowing for sharing of the Persister cache data between stores.Note: When using a parser and a disk cache, the parser will be called after fetching from disk and not between the fetcher and persister which will allow your persister to work on the network stream directly.Bonus: FileSystem & SourcePersister
You may have noticed in the first example that we were using something called a SourcePersister. We’ve found the fastest form of persistence is streaming network responses directly to disk. As a result, we have included a separate artifact with a reactive FileSystem which depends on Okio BufferedSources. We have also included a SourcePersister which will give you disk caching that works beautifully with the middleware: GsonSourceParser. Let’s revisit an example that is structured like our first one, this time looking at a real Store we built for our New York Times Best Sellers screen:We recommend using the above builder to build most Stores. The SourcePersister implementation has a tiny memory footprint as it will stream bytes from network to disk and then from disk to parser. The streaming nature of our stores allows us to download dozens of 1MB+ JSON responses without worrying about OOM on low-memory devices. As mentioned above, Stores allow us to do things like calling bookStore.get() a dozen times asynchronously before our Main Activity finishes loading without blocking the main thread or flooding our network.Conclusion
We thought about what is truly necessary for data retrieval and concluded we only really need files, Guava caches, and a Reactive API — no loaders, content providers, sync adapters, or databases required. We enjoy our lightweight setup and hope you will too. We’d love to hear about what you build. And your contributions are welcome as well.