I work on the Content API team at the New York Times and we have a lot of legacy code. Over the past year I spent months modernizing our platform for our continuous delivery initiative. If you have a lot of legacy code, and the people before you weren’t developing with continuous delivery practices, chances are you have your own fair share of challenges. One of the tougher challenges I faced was learning how to test the systems I inherited, and one of those platforms I inherited was our Varnish stack.Varnish (Varnish Cache) is a caching proxy server that’s full of features. It’s written in the C language and has its own “Varnish configuration language,” VCL. VCL has a lot of features you can adjust to make Varnish do what you need it to do, but not everything. If you want to add features, you can either create your own module, or you can add a feature using inline C. When our VCL was created, we included inline C, which is frowned upon now. C is powerful, but it’s also easy to make big mistakes and it isn’t a language our team uses often. So, after careful analysis, I determined that I could replace the inline C with VCL, which would make the VCL easier to read and maintain. But I needed a good way to test my changes. Testing VCL, which is necessary for continuous delivery, was painful in the beginning. When I started testing, I would start up a development server, make the modifications to the VCL, restart varnish, use curl to make a request and tail the logs or examine the output to verify everything worked correctly. Pretty painful. I did some digging around and eventually discovered there’s an easier way. Learning how to test VCL wasn’t easy, but it can be, and that’s what I want to share with you in this post; how to test varnish VCL.Let’s imagine a real-life feature and how we can go about testing the feature. Programmers use jQuery and sometimes turn on jQuery cache busting. When enabled, jQuery adds a timestamp, e.g., _=1331829184859, to the query string in an attempt to bust the cache. If I strip the query string parameter, I can prevent jQuery from busting our cache. Here’s one way I could clean our URL using VCL:The first if statement strips the _=1331829184859 and the rest of the lines are there to clean the URL so it isn’t left with unneeded characters. The URL is reset on line 11.How can I test this code? I could start a Varnish server with a backend Apache or Nginx instance that logs requests, issue a variety of curl requests and then manually verify the logs, but there’s an easier way. Varnish ships with the ability to test using the testing tool varnishtest. Varnishtest gives you the ability to write VCL tests you can run on the command line or as part of your build process. Here’s an example:Line 1 is just for documentation purposes. Lines 2 – 6 define a server that will accept a request and issue a response. Since I intend to clean the URL before it get’s passed to a backend server, I added a test to verify the backend URL sent to the server with the expect syntax on line 4. If the value doesn’t match, the test stops and you get lots of debugging style output.Line 7 is the syntax to add a backend definition and VCL. Line 8 is optional. I added it to illustrate that you’re allowed to import vmods. At line 9 I define the vcl_recv subroutine and lines 10 – 16 has the logic I need to remove the cache busting parameter.Lines 19 – 21 define vcl_deliver to set a response header. I did this to illustrate one way to validate logic during a client request. Line 23 is where I define a client. The client is where you issue requests with the txreq (transmit request) and receive the response with rxresp (receive response.) At line 26, I use expect to verify the test variable is as expected. Adding expect in the client logic is a better way to test multiple inputs. I kept the example short, but it’s trivial to add multiple txreq -url, rxresp, expect lines to test different inputs. You can also copy and paste the client c1 to create c2, c3…cN clients.Line 28 is where I run the client logic.Our tests are saved in files e.g. test01.vtc. Assuming you compiled and installed Varnish in the standard locations, running varnishtest is this easy:When the test fails, you get a lot of output to look at. Normally, code that passes your tests will produce very little output. However, you can run your tests in “verbose” mode -v to get full output. For the simple test above, a passing test in verbose mode produces 253 lines of output. A failing tests produces fewer lines of output, but only a few less: 189.Varnishtest allows you some flexibility as well. If you’re building and testing tweaks to Varnish, you can specify what varnishd binary file to use with -D flag, e.g.:You can also use the -D option to your advantage and pass variables to your test, since ${varnishd} (or anything else defined with -D) will be available to your VCL when the test is compiled and run. For example, when building and compiling custom Varnish modules, you can import the library from the build directory, e.g.:Testing with varnishtest made a huge impact when working with my VCL. I can quickly and easily add logic and test theories on my local vagrant box. There is a bit of a learning curve to get started with varnishtest, but the official documentation and the book are useful and hopefully this post helps too.